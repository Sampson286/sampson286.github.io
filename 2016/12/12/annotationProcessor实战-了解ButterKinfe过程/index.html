<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>annotationProcessor实战,了解ButterKinfe过程 | Zyc</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="注解的简介简介

Annotations, a form of metadata, provide data about a program that is not part of the program itself. Annotations have no direct effect on the operation of the code they annotate. 

注释是元数据的一种">
<meta property="og:type" content="article">
<meta property="og:title" content="annotationProcessor实战,了解ButterKinfe过程">
<meta property="og:url" content="http://yoursite.com/2016/12/12/annotationProcessor实战-了解ButterKinfe过程/index.html">
<meta property="og:site_name" content="Zyc">
<meta property="og:description" content="注解的简介简介

Annotations, a form of metadata, provide data about a program that is not part of the program itself. Annotations have no direct effect on the operation of the code they annotate. 

注释是元数据的一种">
<meta property="og:image" content="http://i.imgur.com/yiUlVMS.png">
<meta property="og:updated_time" content="2016-12-14T07:33:08.538Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="annotationProcessor实战,了解ButterKinfe过程">
<meta name="twitter:description" content="注解的简介简介

Annotations, a form of metadata, provide data about a program that is not part of the program itself. Annotations have no direct effect on the operation of the code they annotate. 

注释是元数据的一种">
<meta name="twitter:image" content="http://i.imgur.com/yiUlVMS.png">
  
    <link rel="alternative" href="/atom.xml" title="Zyc" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://github.com/zhaoyongchao/zhaoyongchao.github.io/blob/master/img/20160301101824937.jpg?raw=true" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">赵永超</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						
						<li>Über</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/photo">相册</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Android/" style="font-size: 10px;">Android</a> <a href="/tags/AndroidTV/" style="font-size: 10px;">AndroidTV</a> <a href="/tags/Android自定义控件/" style="font-size: 20px;">Android自定义控件</a> <a href="/tags/apk打包/" style="font-size: 10px;">apk打包</a> <a href="/tags/gradle/" style="font-size: 10px;">gradle</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/jenkins打包/" style="font-size: 10px;">jenkins打包</a> <a href="/tags/tip/" style="font-size: 10px;">tip</a> <a href="/tags/源码分析/" style="font-size: 10px;">源码分析</a> <a href="/tags/轮子的制造过程/" style="font-size: 10px;">轮子的制造过程</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">记录自己的工作，也当做自己的个人总结。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">赵永超</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="https://github.com/zhaoyongchao/zhaoyongchao.github.io/blob/master/img/20160301101824937.jpg?raw=true" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">赵永超</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/photo">相册</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-annotationProcessor实战-了解ButterKinfe过程" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/12/12/annotationProcessor实战-了解ButterKinfe过程/" class="article-date">
  	<time datetime="2016-12-12T09:00:30.000Z" itemprop="datePublished">2016-12-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      annotationProcessor实战,了解ButterKinfe过程
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/轮子的制造过程/">轮子的制造过程</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="注解的简介"><a href="#注解的简介" class="headerlink" title="注解的简介"></a>注解的简介</h3><p>简介</p>
<blockquote>
<p>Annotations, a form of metadata, provide data about a program that is not part of the program itself. Annotations have no direct effect on the operation of the code they annotate. </p>
</blockquote>
<p>注释是元数据的一种形式，为程序的元素（类、方法、变量）提供一些说明，但是不会对程序本身造成影响。</p>
<ul>
<li>Annotation 类似一种修饰符，用于修饰包、类型、构造方法、方法、成语变量、参数的声明语句。</li>
<li>Annotation 是一个接口。通过反射来访问annotation信息。根据获取的信息来决定如何使用注解信息来做一些事情。</li>
<li>Annotation 不会对程序造成影响。</li>
<li>Java预言解析器在工作的时候默认是忽略这些annotation，所以在JVM中”不起作用”，只有通过配套的工具才能对这些注解进行访问和处理。<h3 id="Annotation的使用"><a href="#Annotation的使用" class="headerlink" title="Annotation的使用"></a>Annotation的使用</h3></li>
<li>Annotation的声明需要通过@interface这个关键字。会继承Annotation接口。</li>
<li>Annotation的方法必须声明为无参数、无异常。方法名代表成员变量名，方法的返回值代表了成员变量的类型。而且返回值类型必须为基本数据类型、Class类型、枚举类型、String类型、Annotation类型或者由前面任意一种类型组成的一维数组。方法后面可以使用default和一个默认数值来声明一个成员变量的默认值，null不能作为成员变量的默认值。</li>
<li>注解中如果只有一个默认属性，可以直接使用value()函数，一个属性也没有的则表示该Annotation为Mark Annotation。<br>例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface Test &#123;</span><br><span class="line">    String value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>直接使用@Test(“demo”)，等同于@Test(value=”demo”)<br>添加默认值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface TestDefault &#123;</span><br><span class="line">    public String description() default &quot;demo&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Annotation的作用"><a href="#Annotation的作用" class="headerlink" title="Annotation的作用"></a>Annotation的作用</h3><p>很多使用作为一种辅助途径，应用在软件框架或工具中。这些工具类可以根据不同的Annotation心采取不同的处理，具有”让编译器进行编译检查的功能”<br><a id="more"></a></p>
<h3 id="具体可分为以下三种作用："><a href="#具体可分为以下三种作用：" class="headerlink" title="具体可分为以下三种作用："></a>具体可分为以下三种作用：</h3><ol>
<li>标记，告诉编译器一些信息(RetentionPolicy.SOURCE)</li>
<li>运行时动态处理，如通过反射的信息获取注解信息进行操作(RetentionPolicy.RUNTIME)</li>
<li>编译时动态处理，如生成代码或XML(RetentionPolicy.CLASS)<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3>标准的Annotation<br>从1.5开始就自带三张标准的Annotation类型：</li>
</ol>
<ul>
<li>Override<br>它是一种marker类型的Annotation，用来标注方法，说明被它标注的方法是重载了父类中的方法。如果我们使用了该注解到一个没有覆盖父类方法的方法时，编译器就会提示一个编译错误的警告。</li>
<li>Deprecated<br>它也是一种marker类型的Annotation。当方法或者变量使用该注解时，编译器就会提示该方法已经废弃。</li>
<li>SuppressWarnings<br>它不是marker类型的Annotation。用户告诉编译器不要再对该类、方法或者成员变量进行警告提示。<br>元Annotation<br>元Annotation是指用来定义Annotation的Annotation</li>
<li>@Retention<br>保留时间，可为RetentionPolicy.SOURCE(源码时)、RetentionPolicy.CLASS(编译时)、RetentionPolicy.RUNTIME(运行时)，默认为CLASS。如果值为RetentionPolicy.SOURCE那大多都是Mark Annotation，例如:Override、Deprecated。SOURCE表示仅存在于源码中，在class文件中不会包含。CLASS表示会在class文件中存在，但是运行时无法获取。RUNTIME表示会在class文件中存在，并且在运行时可以通过反射获取。</li>
<li>@Target<br>用来标记可进行修饰哪些元素，例如ElementType.TYPE、ElementType.METHOD、ElementType.CONSTRUCTOR、ElementType.FIELD、ElementType.PARAMETER等，如果未指定则默认为可修饰所有。</li>
<li>@Inherited<br>子类是否可以继承父类中的该注解。它所标注的Annotation将具有继承性。</li>
<li>@Documented<br>是否会保存到javadoc文档中。<h3 id="自定义Annotation"><a href="#自定义Annotation" class="headerlink" title="自定义Annotation"></a>自定义Annotation</h3>在Android的获取控件中都需要findViewById()来获取，通过注解的来获取到Id的值进行绑定例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.FIELD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface ViewInject&#123;</span><br><span class="line">    int viewId();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注解声明完后，可以定义一些控件来使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@ViewInject(viewId = R.id.test)</span><br><span class="line">    private TextView test;</span><br></pre></td></tr></table></figure></p>
<h3 id="Annotation解析"><a href="#Annotation解析" class="headerlink" title="Annotation解析"></a>Annotation解析</h3><ul>
<li>当Java源代码被编译时，编译器的一个插件annotation处理器则会处理这些annotation。<br>处理器可以产生报告信息，或者创建附加的Java源文件或资源。<br>如果annotation本身被加上了RententionPolicy的运行时类，<br>则Java编译器则会将annotation的元数据存储到class文件中。然后Java虚拟机或其他的程序可以查找这些元数据并做相应的处理。</li>
<li>除了annotation处理器可以处理annotation外，我们也可以使用反射来处理annotation。Java SE 5有一个名为AnnotatedElement的接口，<br>Java的反射对象类Class,Constructor,Field,Method以及Package都实现了这个接口。<br>这个接口用来表示当前运行在Java虚拟机中的被加上了annotation的程序元素。<br>通过这个接口可以使用反射读取annotation。AnnotatedElement接口可以访问被加上RUNTIME标记的annotation，<br>相应的方法有getAnnotation,getAnnotations,isAnnotationPresent。<br>由于Annotation类型被编译和存储在二进制文件中就像class一样，<br>所以可以像查询普通的Java对象一样查询这些方法返回的Annotation。</li>
</ul>
<p>运行时Annotation解析</p>
<p>该类是指@Retention为RUNTIME的Annotation。<br>该类型的解析其实本质的使用反射。反射执行的效率是很低的<br>如果不是必要，应当尽量减少反射的使用，因为它会大大拖累你应用的执行效率。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void viewInject(Activity activity)&#123;</span><br><span class="line">        Class&lt;? extends Activity&gt; obj=activity.getClass();</span><br><span class="line">        Field[] fields=obj.getDeclaredFields();//获取声明的字段</span><br><span class="line">        for (Field field :fields)&#123;</span><br><span class="line">            ViewInject viewInject=field.getAnnotation(ViewInject.class);</span><br><span class="line">            if(viewInject!=null)&#123;</span><br><span class="line">                int viewId=viewInject.viewId();</span><br><span class="line">                if(viewId!=-1)&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Method method=obj.getMethod(&quot;findViewById&quot;,int.class);</span><br><span class="line">                        Object view=method.invoke(activity,viewId);</span><br><span class="line">                        field.setAccessible(true);//设置属性可以访问</span><br><span class="line">                        field.set(activity,view);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="在Android的开发中使用ButterKnife他也是使用到了注解"><a href="#在Android的开发中使用ButterKnife他也是使用到了注解" class="headerlink" title="在Android的开发中使用ButterKnife他也是使用到了注解"></a>在Android的开发中使用ButterKnife他也是使用到了注解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//声明的保留时期为编译时期</span><br><span class="line">@Retention(CLASS) @Target(FIELD)</span><br><span class="line">public @interface BindView &#123;</span><br><span class="line">  /** View ID to which the field will be bound. */</span><br><span class="line">  @IdRes int value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用的是编译类型的注解，这样就不会通过反射来获取数值，不会影响性能。</p>
<h3 id="编译类型注解的过程："><a href="#编译类型注解的过程：" class="headerlink" title="编译类型注解的过程："></a>编译类型注解的过程：</h3><p><img src="http://i.imgur.com/yiUlVMS.png" alt=""></p>
<h3 id="编译类型注解的解析"><a href="#编译类型注解的解析" class="headerlink" title="编译类型注解的解析"></a>编译类型注解的解析</h3><ul>
<li>该类型注解值是@Retention为CLASS的Annotation，由APT(Annotaion Processing Tool)自动进行解析。是在编译时注入，所以不会像反射一样影响效率问题。</li>
<li>根据sun官方的解释，APT（annotation processing tool）是一个命令行工具，<br>它对源代码文件进行检测找出其中的annotation后，使用annotation processors来处理annotation。<br>而annotation processors使用了一套反射API并具备对JSR175规范的支持。</li>
<li>annotation processors处理annotation的基本过程如下：</li>
</ul>
<ol>
<li>APT运行annotation processors根据提供的源文件中的annotation生成源代码文件和其它的文件（文件具体内容由annotation processors的编写者决定）</li>
<li>接着APT将生成的源代码文件和提供的源文件进行编译生成类文件。</li>
</ol>
<ul>
<li>APT在编译时自动查找所有继承自AbstractProcessor的类，然后调用他们的process方法去处理，这样就拥有了在编译过程中执行代码的能力</li>
<li>所以我们需要完成的工作：</li>
</ul>
<ol>
<li>自定义类继承AbstractProcessor，重写process方法。</li>
<li>注册处理器，让APT能够检测的到。</li>
</ol>
<ul>
<li>但是在Android Studio死活提示找不到AbstractProcessor类，这是因为注解是javase中javax包里面的，android.jar默认是不包含的，所以会编译报错.<br>解决方法就是新建一个Module，在选择类型时将该Module的类型选为Java Library。<br>然后在该Module中创建就好了Processor就好了，完美解决</li>
<li>Android Studio中创建一个Android工程。</li>
<li>新建一个Module，然后选择Java Library类型，并且让app依赖该module</li>
<li>在annotations的module中创建注解类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.CLASS)</span><br><span class="line">public @interface AnnotationTest &#123;</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建自定义的Processor类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@SupportedAnnotationTypes(&quot;com.example.AnnotationTest&quot;)</span><br><span class="line">@SupportedSourceVersion(SourceVersion.RELEASE_7)</span><br><span class="line">public class TestProcessor extends AbstractProcessor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123;</span><br><span class="line">        System.out.println(&quot;process&quot;);</span><br><span class="line">        for (TypeElement te : annotations) &#123;</span><br><span class="line">            for (Element element : roundEnv.getElementsAnnotatedWith(te)) &#123;</span><br><span class="line">                AnnotationTest annotation = element.getAnnotation(AnnotationTest.class);</span><br><span class="line">                String value = annotation.value();</span><br><span class="line">                System.out.println(&quot;type : &quot; + value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong>@SupportedAnnotationTypes(“com.charon.AnnotationTest”)来指定要处理的注解类。<br>@SupportedSourceVersion(SourceVersion.RELEASE_7)指定编译的版本。这种通过注解指定编译版本和类型的方式是从Java 1.7才有的。<br>对于之前的版本都是通过重写AbstractProcessor中的方法来指定的。</p>
<ul>
<li>注册处理器<br>我们自定义了Processor那如何才能让其生效呢?就是在annotations的java同级目录新建resources/META-INF/services/javax.annotation.processing.Processor文件<br>然后在javax.annotation.processing.Processor文件中指定自定义的处理器，如:<br><code>com.example.TestProcessor</code></li>
<li>在app中进行使用<br>进行Build会在控制台看到输出的信息。<h3 id="上面只是一个简单的例子，如果你想用编译时注解去做一些更高级的事情，例如自动生成一些代码，那你可能就会用到如下几个类库"><a href="#上面只是一个简单的例子，如果你想用编译时注解去做一些更高级的事情，例如自动生成一些代码，那你可能就会用到如下几个类库" class="headerlink" title="上面只是一个简单的例子，如果你想用编译时注解去做一些更高级的事情，例如自动生成一些代码，那你可能就会用到如下几个类库:"></a>上面只是一个简单的例子，如果你想用编译时注解去做一些更高级的事情，例如自动生成一些代码，那你可能就会用到如下几个类库:</h3></li>
<li>以前使用<a href="https://bitbucket.org/hvisser/android-apt" target="_blank" rel="external">android-apt</a>，Gradle plugin  2.2提供annotationProcessor来代替了android-apt，还是建议使用官方的<blockquote>
<p>As of the Android Gradle plugin version 2.2, all functionality that was previously provided by android-apt is now available in the Android plugin. This means that android-apt is officially obsolete<br>Here are the steps to migrate:<br>Make sure you are on the Android Gradle 2.2 plugin or newer.<br>Remove the android-apt plugin from your build scripts<br>Change all apt, androidTestApt and testApt dependencies to their new format:</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;com.google.dagger:dagger:2.0&apos;</span><br><span class="line">    annotationProcessor &apos;com.google.dagger:dagger-compiler:2.0&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://github.com/google/auto" target="_blank" rel="external">Google Auto</a>的作用：<br>Google Auto的主要作用是注解Processor类，并对其生成META-INF的配置信息，<br>可以让你不用去写META-INF这些配置文件，只要在自定义的Processor上面加上@AutoService(Processor.class)</li>
<li><a href="https://github.com/square/javapoet" target="_blank" rel="external">Square javapoet</a>的作用：<br>javapoet:A Java API for generating .java source files.可以更方便的生成代码，它可以帮助我们通过类调用的形式来生成代码。<h3 id="自定义编译时注解"><a href="#自定义编译时注解" class="headerlink" title="自定义编译时注解"></a>自定义编译时注解</h3>在自定义注解时，一般来说可能会建三个modules:</li>
<li>app module:写一些使用注解的android应用逻辑。</li>
<li>api module:定义一些可以在app中使用的注解。它会被app以及compiler使用。</li>
<li>compiler module:定义Processor该module不会被包含到应用中，它只会在构建过程中被使用。在编译的过程中它会生成一些java文件，而这些java文件会被打包进apk中。<br>我们可以在该module中使用auto以及javapoet。<br>开始进行配置：</li>
<li><p>compiler module中配置auto以及javapoet</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;)</span><br><span class="line">    //Google Auto的主要作用是注解Processor类，并对其生成META-INF的配置信息，</span><br><span class="line">    //可以让你不用去写META-INF这些配置文件，只要在自定义的Processor上面加上@AutoService(Processor.class)</span><br><span class="line">    compile &apos;com.google.auto.service:auto-service:1.0-rc2&apos;</span><br><span class="line">    //可以更方便的生成代码，它可以帮助我们通过类调用的形式来生成代码。</span><br><span class="line">    compile &apos;com.squareup:javapoet:1.7.0&apos;</span><br><span class="line">    compile project(&apos;:apimodule&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>app module中gradle配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compile project(&apos;:compilermodule&apos;)</span><br><span class="line">annotationProcessor project(&apos;:compilermodule&apos;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在api module 中创建一个注解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.CLASS)</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">public @interface Factory &#123;</span><br><span class="line">    String id();</span><br><span class="line">    Class type();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在compiler module中自定义一个Processor</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@AutoService(Processor.class)</span><br><span class="line">public class MyProcessor extends AbstractProcessor &#123;</span><br><span class="line">    //初始化操作的方法，RoundEnvironment会提供很多有用的工具类Elements、Types和Filer等。</span><br><span class="line">    @Override</span><br><span class="line">    public synchronized void init(ProcessingEnvironment processingEnv) &#123;</span><br><span class="line">        super.init(processingEnv);</span><br><span class="line">    &#125;</span><br><span class="line">    //这相当于每个处理器的主函数main()。在该方法中去扫描、评估、处理以及生成Java文件。</span><br><span class="line">    @Override</span><br><span class="line">    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123;</span><br><span class="line">        System.out.println(&quot;Hello Wolrd,Custom Processor&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //这里你必须指定，该注解器是注册给哪个注解的</span><br><span class="line">    @Override</span><br><span class="line">    public Set&lt;String&gt; getSupportedAnnotationTypes() &#123;</span><br><span class="line">        return super.getSupportedAnnotationTypes();</span><br><span class="line">    &#125;</span><br><span class="line">    //用来指定你使用的java版本。通常这里会直接放回SourceVersion.latestSupported()</span><br><span class="line">    @Override</span><br><span class="line">    public SourceVersion getSupportedSourceVersion() &#123;</span><br><span class="line">        return SourceVersion.latestSupported();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从jdk 1.7开始，可以使用如下注解来代替getSupporedAnnotationTypes()和getSupportedSourceVersion()方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@SupportedSourceVersion(SourceVersion.latestSupported())</span><br><span class="line">@SupportedAnnotationTypes(&#123;</span><br><span class="line">   // 合法注解全名的集合</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2016/12/06/Retrofit使用及分析/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Retrofit使用及分析</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="annotationProcessor实战-了解ButterKinfe过程" data-title="annotationProcessor实战,了解ButterKinfe过程" data-url="http://yoursite.com/2016/12/12/annotationProcessor实战-了解ButterKinfe过程/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 赵永超
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>